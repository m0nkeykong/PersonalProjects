 

 

Software Engineering Department 
 

Computer Organisation and Programming Course  
final assignment 

 

Pocket Calculator application 

 

 

Written by: 

Haim Elbaz 

& 

Ran Shoshan 

September 04 2016 

 

 

 

 

Lecturer: Dr Yigal Hoffner 

 

 

 

TABLE OF CONTENTS 

TABLE OF CONTENTS1 

1POCKET CALCULATOR APPLICATION DESIGN2 

1.1Introduction2 

1.2Major design/implementation decisions2 

1.3The high-level algorithms2 

2THE USER GUIDE4 

3PROGRAM LISTING5 

￼ 

 

Page Break
 

Pocket Calculator application design 

 

Introduction 

Welcome to Haim and Ran's calculator – They were also the first Casio planners , and the developers of the  5th arithmetic action that will be published in the next renovated calculator. 

This Pocket Calculator is a calculator that supports 4 basic operators: +,-,/,*   and numbers range between    (-32,767) – (+32,768).  

 

Major design/implementation decisions 

 

We took in mind is how a calculator functions. 

in order to bring the user the ultimate calculating experience,  we first ask for an operator to use it in the echo line of work. (for example, the entered assignment will be printed to the screen like this : [ 5 + 87 ]). 

 

 

 

 

The high-level algorithms  

Int ADDITION_FUNC (UNO, DOS); 

Int MINUS_FUNC (UNO, DOS);   

Int MULTIPLY_FUNC (UNO, DOS);  

Int DIVIDE_FUNC (UNO, DOS); 

 

Char OPERAND = 0 ; 

 

int main()  

{ 

While(OPERAND != X) 

{ 

Int TEMP1 =0 , TEMP2 =0 , TEMP3 =0 , TEMP4 =0 , TEMP5 =0 , TEMP6 =0 , TEMP7 =0 ; 

Int UNO = 0 ; 

Int DOS = 0 ; 

Int SOLUCION = 0 ; 

 

 

Printf("Please Insert Operator (* , - , + , /) (Enter X To Terminate):") ;         

Scanf("%c",& OPERAND); 

 

If (OPERAND == X) 

       Break; 

 

Printf("Please Enter Two Number (Enter For Insertion):"); 

Scanf(" %d %d " , &UNO , &DOS ) 

 

 

 

If ( (UNO || DOS > 32767 ) || ( UNO || DOS < -32768 ) ) 

                       printf( "Input Error!"); 

              

 

If (OPERAND == ‘+’)  

         {          

          SOLUCION = ADDITION_FUNC (UNO, DOS);  

              Printf("The Result Is:  %d" , SOLUCION);  

Return;  

         } 

  

Else if (OPERAND == ‘-‘)  

         {  

          SOLUCION = MINUS_FUNC (UNO, DOS);   

Printf("The Result Is:  %d" , SOLUCION);  

  Return;  

         }  

 

Else if (OPERAND == ‘*’)  

         {  

           SOLUCION = MULTIPLY_FUNC (UNO, DOS);  

  Printf("The Result Is:  %d" , SOLUCION); 

Return;  

         }          

 

Else if (OPERAND == ‘/’)  

         {          

           SOLUCION = DIVIDE_FUNC (UNO, DOS);  

                Printf("The Result Is:  %d" , SOLUCION); 

 Return;  

          }  

Else  printf( "Input Error!"); 

 

} 

 

 

 

Int ADDITION_FUNC (UNO, DOS); 

{ 

Return UNO + DOS ; 

} 

 

Int MINUS_FUNC (UNO, DOS);   

{ 

Return UNO - DOS ; 

} 

 

Int MULTIPLY_FUNC (UNO, DOS);  

{ 

Return UNO * DOS ; 

} 

 

 

 

 

Int DIVIDE_FUNC (UNO, DOS); 

{ 

If ( DOS == 0 ) 

Printf ("Input Error!"); 

 

Return UNO / DOS ; 

} 

 

 

Transformations 

         

Int ADDITION_FUNC (UNO, DOS) 

{ 

Return UNO + DOS ; 

} 

 

Int MINUS_FUNC (UNO, DOS)   

{ 

DOS = DOS * (-1) ; 

Return UNO + DOS ; 

} 

 

 

int MULTIPLY_FUNC (int UNO, int DOS)  

{  

            int MULT_COUNT, SUMMARY =0;  

            for (MULT_COUNT = DOS; MULT_COUNT > 0; MULT_COUNT --)  

                        {  

                                    SUMMARY = SUMMARY + UNO;  

                        }  

            return SUMMARY;  

}  

 

 

 

 

Int DIVIDE_FUNC (UNO, DOS) 

{  

      If ( DOS == 0 ) 

Printf ("Input Error!"); 

 

 

            int SUMMARY =0;  

            DOS = DOS * (-1);  

                     while (UNO > 0)  

                        {  

                                 UNO = UNO + DOS;  

                                 SUMMARY ++;  

                        }  

            return SUMMARY;  

}  

 

The User Guide 

In order to start, you will be asked to enter an Operator to choose the relevant  function. 

(in order to terminate, insert capital X in function line). 

After Operator is inserted, you will be asked to enter two numbers. 

Then the calculator will sum them up based on you're decision. 

The result will be printed and then the calculator will re-start itself. 

 

Extra Features: 

The calculator identifies limited number range, dividends by zero, and all kind of unrealistic  

Mathematic errors, and notify the user about them. 

 

 

 

 

 

 

 

 

 

 

Program listing 

Main,CLA// RESTART SEQUENCE 

STATEMP1 

STATEMP2 

STATEMP3 

STATEMP4 

STATEMP5 

STA TEMP6 

STA TEMP7 

STAUNO 

STADOS 

STAOPERAND 

LDAINTROO  

BSAPRINT_FUNC// PRINT INTRO 

BSAOPER_INS// INSERTION OF REQUESTED OPERAND 

STAOPERAND 

ADDTERMINATION// CHECK IF  OPERAND ENTERED IS 'X'  

SZA 

BUNINSERT// IF NOT TERMNATED - CONTINUE 

HLT// IF TERMINATED - EXIT 

 

 

 

 

 

 

INSERT,LDANUMBERS_INS 

BSAPRINT_FUNC// PRINT NUMBRE INSERTION TEXT 

LDAOPERAND 

BSAINSERTION 

STADOS// STORE IN DOS 

ADDNUM_RANGE 

SPA// IF LIMIT VALUE EXCEEDS  

BUNINSERT// THEN RETURN TO INSERT 

BSACHECK_SIGN// CHECK SIGN AND RANGE FOR 1ST NUMBER   

SZA 

BUNERR_MSG//IF NUMBER IS INVAILD – PRINT ERROR MSG 

LDA DOS 

BSACHECK_SIGN// CHECK SIGN AND RANGE 2ND NUMBER   

SZA// IF NUMBER IS INVAILD – PRINT ERROR MSG 

BUNERR_MSG 

 

 

 

 

 

 

CHCK_IF_PLUS,LDAOPERAND// CHECK IF ENTERED OPERAND IS "+" 

ADDPLUS 

SZA 

BUN CHCK_IF_MINUS// IF NOT "+" GO CHECK IF "-" 

LDAUNO  

STATEMP2 

LDADOS 

BSAADDITION_FUNC// GO TO ADDITION FUNCTION AND CALCULATE 

BSAPRNT_RESULT// PRINT THE RESULT 

BUNMAIN// GO TO MAIN AND START AGAIN 

 

 

 

 

 

 

 

 

 

 

CHCK_IF_MINUS,LDAOPERAND// CHECK IF ENTERED OPERAND IS "-" 

ADDMINUS 

SZA 

BUNCHCK_IF_MULT// IF NOT "+" GO CHECK IF "*" 

LDAUNO 

STATEMP3 

LDADOS 

BSAMINUS_FUNC// GO TO MINUS FUNCTION AND CALCULATE 

BSAPRNT_RESULT// PRINT THE RESULT 

BUNMAIN// GO TO MAIN AND START AGAIN 

 

 

CHCK_IF_MULT,LDAOPERAND// CHECK IF ENTERED OPERAND IS "*" 

ADDMULTIPLY 

SZA 

BUNCHECK_IF_DIV// IF NOT "*" GO CHECK IF "*" 

LDAUNO 

STATEMP4 

LDADOS 

BSAMULTIPLY_FUNC// GO TO MULTIPLY FUNCTION AND CALCULATE 

BSAPRNT_RESULT// PRINT THE RESULT 

BUNMAIN// GO TO MAIN AND START AGAIN 

                                              

 

 

 

 

 

 

 

CHECK_IF_DIV,LDAOPERAND// CHECK IF ENTERED OPERAND IS "/" 

ADDDIVIDE 

SZA 

BUNERR_MSG// IF NOT "*" GO CHECK IF, THEN PRINT ERROR MSG 

LDAUNO 

STATEMP5 

LDADOS 

BSADIVIDE_FUNC// GO TO DIVIDNG FUNCTION AND CALCULATE 

BSAPRNT_RESULT// PRINT THE RESULT 

LDAOPERAND 

ADD DIVIDE 

SZA 

BUNMAIN// GO TO MAIN AND START AGAIN 

BSA P_RMNDR 

BUN MAIN// GO TO MAIN AND START AGAIN 

 

 

 

 

 

ERR_MSG,LDAERR_MSG_PTR 

BSAPRINT_FUNC// PRINT ERROR MESSAGE 

BUNMAIN// GO TO MAIN AND START AGAIN 

 

 

///////////////////////////////////////////////////////////////////////MAIN DATA///////////////////////////////////////////////////////////////////////// 

MULTIPLY,HEX-2A// (-)"*" 

DIVIDE,HEX-2F// (-)"/" 

PLUS,HEX -2B // (-)"+" 

MINUS,HEX -2D// (-)"-" 

OPERAND,DEC0 

UNO,DEC0 

DOS,DEC0  

TERMINATION,HEX -58// TERMINATION CHECKER – "X" 

NUM_RANGE,DEC-40000 

INTROO,   HEX 595// INTRO TEXT START 

NUMBERS_INS,HEX 695// NUMBER INSERTION TEXT START 

ERR_MSG_PTR,HEX 795// ERROR MESSAGE TEXT START 

TEMP1,HEX 0 

TEMP2,HEX0 

TEMP3,HEX 0 

TEMP4,HEX 0 

TEMP5,HEX 0 

TEMP6,HEX 0 

TEMP7,HEX 0 

 

 

 

 

/////////////////////////////////////////////////////////////////////////////////FUNCTIONS//////////////////////////////////////////////////////////////////////                                  

PRINT_FUNC,HEX0// TEXT PRINTING FUNCTION 

STA PTTR// STORE PHRASE IN TEMPORARY POINTR 

LDAPTTR I 

OUTPUT,SKO //PRINT SEQUENCE 

BUNOUTPUT 

OUT 

ISZPTTR // PROMOTE TEXT POINTER 

LDAPTTR I 

ADDXXX// CHECK IF TERMINATION TERM IS ACCEPTED 

SZA 

BUNPRINT_CONT// IF NOT ACCEPTED – CONTINUE PRINTING 

BUN PRINT_FUNC I// IF ACCEPTED – RETURN TO MAIN 

PRINT_CONT,LDAPTTR I 

BUNOUTPUT// CONTINUE PRINTING 

 

 

 

 

 

 

 

 

 

////////////////////////////////////////////////////////////////TEXT PRINT FUNCTION DATA////////////////////////////////////////////////////////////// 

PTTR,DEC0// TEXT PRINTING POINTER 

 

 

 

 

 

 

OPER_INS,HEX0// OPERAND INSERTION FUNCTION SEQUENCE 

INPUT,SKI 

BUNINPUT 

INP 

OUT// ECO OPERAND INSERTED 

BUNOPER_INS I// RETURN TO MAIN 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

CHAR2INT, HEX0// CHAR TO INTEGEGER FUNCTION SEQUENCE 

CLA 

STATEMPCHAR  

SKI 

BUNCHAR2INT 

INP 

STATESTINSRT 

BSAIFCHARLEGAL// CHECK IF CHAR IS A LEGAL CHAR (NUMBER) 

SZA//  

BUNFAILED2INS// IF INVALID INSERTION – GO TO FAIL SEQUENCE 

LDATESTINSRT 

ADDMINUS// CHECK IF "-" INSERTED 

SZA 

BUNPOSNOTNEG// IF NO "-" INSERTED – LEAVE NUMBER AS IS 

ISZNEGFLAG// IF "-" INSERTED – RAISE FLAG FOR NEGATIVE  

//NUMBER  

LDATESTINSRT// LOAD INSERTION AGAIN  

OUT// ECHO INSERTION 

BUNCHAR2INT  

POSNOTNEG,LDATESTINSRT 

OUTPUT_C,SKO 

BUNOUTPUT_C 

STATAMBOLINA 

ADDM_CR_CHCK// CHECK IF CR ENTERED 

SZA 

BUNECHO_P// GO AND ECHO 

VAMOS_ECHO,LDATAMBOLINA // RETURN AND ECHO AGAIN 

STATEMPCHAR 

ADD M_CR_CHCK 

SZA 

BUN TCH2NM// IF NOT CR, MUST BE NUMBER 

BUNEND_ECHO// IF CR ENTERED FINISH LOOP 

TCH2NM, LDATEMPCHAR// CONVERTS CHAR TO NUMBER 

ADDM_ASCII_VAL 

STATEMPCHAR 

LDATEMPNUMB  

BSABABAM // GO TO MULTIPLING FUNCTION 

ADDTEMPCHAR// ADD MULTIPLYED NUMBER TO ALREADY SAVED NUMBER 

STATEMPNUMB 

BUNCHAR2INT 

END_ECHO,LDANEGFLAG// CHECK IF NUMBER IS NEGATIVE BY CHECKING THE FLAG 

SZA 

BUNIFNUMWASNEG// IF NUMBER IS NEGATIVE, MAKE IT SO 

LDATEMPNUMB// IF FLAG IS NOT RAISED – NUMBER IS AS IS 

BUNCHAR2INT I 

IFNUMWASNEG,CLA// IF THE NUMBER IS NEGATIVE 

STANEGFLAG// RESET THE FLAG FOR NEXT NUMBER 

LDATEMPNUMB 

CMA// TRANSFORM NUMBER TO NEGATIVE 

INC 

BUNCHAR2INT I 

 

ECHO_P,LDATAMBOLINA 

OUT// DO THE ECHOs 

BUNVAMOS_ECHO// ECHO AGAIN 

FAILED2INS,LDAM_NUM_RANGE// RETURN MAXIMUM RANGE TO RECEIVE ERROR 

BUNCHAR2INT I 

 

/////////////////////////////////////////////////////////////////CHAR TO INTEGER DATA/////////////////////////////////////////////////////////////////////// 

TEMPNUMB,DEC 0 

TEMPCHAR,   DEC 0  

M_ASCII_VAL,HEX-30// ASCII VALUE (NEGATIVE FORM) 

TAMBOLINA,DEC0 

TESTINSRT,DEC0 

NEGFLAG,DEC0 

M_NUM_RANGE,HEX40000                                       

 

 

BABAM,HEX0// FUNCTION THAT MULTIPLIES DIGITS BY 10 

CLE// BY USING THE BINARY TECHNIQUE 

CIL 

CIL  

CIL 

ADD TEMPNUMB  

ADD TEMPNUMB  

BUNBABAM   I // RETURN 

 

 

 

 

 

 

 

IFCHARLEGAL,HEX0// FUNCTION THAT CHECK OF ENTERED CHAR IS LEGAL  

STAANOTHERTEMP 

ADDM_CR_CHCK// CHECK IF ENTERED VALUE IS CR (ENTER) 

SZA 

BUNMINUS_CHCK// IF NOT, CHECK IF IT’S A "-" SIGN 

BUNTRUE// IF CR IS ENTERED – TO GO TRUE 

MINUS_CHCK,LDAANOTHERTEMP 

ADDMINUS// CHECK IF IT’S A "-" SIGN (NEGATIVE NUMBER) 

SZA 

BUNRANGE_CHCK// IF NOT A "-" SIGN, CHECK NUMBER RANGE 

BUNTRUE// IF A "-" SIGN, GO TO TRUE 

RANGE_CHCK,LDAANOTHERTEMP 

ADDLOWEST// CHECK WITH LOWEST VARIABLE ACCEPTED 

SNA  

BUNCHECK_HIGH// LOWER RANGE ACCEPTED – CHECK HIGH RANGE 

BUNFALSE// LOWER RANGE DISSAPPROVED – INVALID INPUT 

 

 

 

 

CHECK_HIGH,LDAANOTHERTEMP 

ADDHIGHEST 

SPA  

BUNTRUE// HIGHER RANGE ACCEPTED – NUMBER WITHIN 

//RANGE 

BUNFALSE// HIGHTER RANGE DISSAPPROVED – INVALID INPUT 

TRUE,CLA 

BUNIFCHARLEGAL I// INSERTION CORRECT – RETURN TO MAIN AND CONTINUE 

FALSE,LDAANOTHERTEMP// INSERTION DENIED – PRINT ERROR MESSAGE AND RETRY 

OUT 

LDAINP_DENIED 

BSAPRINT_FUNC// PRINT TEXT FOR INPUT DENIED, TRY AGAIN 

LDADENIED 

BUNIFCHARLEGAL I// RETURN FAILED TO MAIN 

/////////////////////////////////////////////////////////////////////RANGE CHECK DATA//////////////////////////////////////////////////////////////////////////////// 

INP_DENIED,HEX900 

ANOTHERTEMP,DEC0 

LOWEST,HEX-30// LOWEST NUMBER ACCEPTED (0) 

HIGHEST,HEX-39// HIGHEST NUMBER ACCEPTED (9) 

DENIED,DEC1// FAIL VALUE FOR CHECK 

M_CR_CHCK,HEX-0D// CR CHECK VALUE (- CR)  

 

 

 

 

 

INSERTION,HEX0// FUNCTION THE INSERT THE ENTERED OPERATOR   

STAOPERAND_TMP 

CLA 

STATEMPNUMB 

BSACHAR2INT// CONVERT TO INTEGER 

ADDNUM_RANGE 

SZA 

BUNCHOKO// IF INSERTION IN RANGE CONTINUE (IN JAPANESE) 

LDANUM_RANGE  

BUNINSERTION I// IF NUMBER RANGE EXCEEDED - RETURN ERROR 

//VALUE 

CHOKO,LDA TEMPNUMB 

STA UNO 

LDAOPERAND_TMP 

OUT// ECHO OPERAND 

CLA 

STATEMPNUMB// RESET FOR NEXT INSERTION 

BSACHAR2INT 

BUNINSERTION I 

//////////////////////////////////////////////////////////////////INSERTION FUNCTION DATA///////////////////////////////////////////////////////////////////////// 

OPERAND_TMP,DEC0 

 

 

 

 

 

CHECK_SIGN,  HEX0// FUNCTION THAT CHECKS SIGN AND RANGE OF  

//NUMBERS  

STATEMPORARY 

SNA 

BUNCK_POS_RNG// IF NUMBER IS POSITIVE 

BUNCK_NEG_RNG// IF NUMBER IS NEGATIVE 

CK_POS_RNG,ADDPOSMAXRNG// IF NUMBER IS POSITIVE – CHECK POSITIVE RANGE 

SPA 

BUNVALID// IN RANGE, RETURN TRUE 

LDAFAALSE// NOT IN RANGE, RETURN FALSE 

BUNCHECK_SIGN I 

CK_NEG_RNG,LDATEMPORARY// IF NUMBER IS NEGATIVE – CHECK NEGATIVE RANGE 

ADDNEGMAXRNG 

SNA 

BUNVALID// IN RANGE, RETURN TRUE 

LDAFAALSE// NOT IN RANGE, RETURN FALSE 

BUNCHECK_SIGN I 

VALID,LDATRRUE// VALUE IN RANGE – RETURN TRUE 

BUNCHECK_SIGN I 

/////////////////////////////////////////////////////////////////RANGE CHECK DATA///////////////////////////////////////////////////////////////////////////////// 

FAALSE,DEC1 

TRRUE,DEC0 

TEMPORARY,DEC0 

POSMAXRNG,DEC-32768// POSITIVE MAXIMUN DECIMAL RANGE 

NEGMAXRNG,DEC32767// NEGATIVE MINIMUM DECIMAL RANGE 

 

 

 

 

 

////////////////////////////////////////////////////////////////OPERANDS FUNCTIONS/////////////////////////////////////////////////////////////////////// 

ADDITION_FUNC,HEX0// ADDITON FUNCTION INITIATED 

STA SHAKIRA 

ADDTEMP2 

BUNADDITION_FUNC I// RETURN TO MAIN 

 

 

 

 

 

 

MINUS_FUNC,HEX0// MINUS FUNCTION INITIATED 

CMA// TRANSFORM NUMBER TO NEGATIVE FORM 

INC 

STA BEYONCE  

ADDTEMP3// SUBTRACT 

BUNMINUS_FUNC I// RETURN TO MAIN 

 

 

 

 

 

MULTIPLY_FUNC,HEX0// MULTIPLY FUNCTION INITIATED 

STA JAYLOO 

CLA 

STASUMMARY 

STAM_FLAG_UNO// SIGN FLAG FOR 1ST NUMBER 

STAM_FLAG_DOS// SIGN FLAG FOR 2ND NUMBER 

STAMULT_COUNT// MULTIPLICATION COUNTER 

LDAJAYLOO 

BSACHCK_SIGN// CHECK IF DOS IS POSITIVE 

SZA 

BUNSHLILI// IF DOS I NEGATIVE – GO TO SHLILI 

STAM_FLAG_DOS// MARK NUMBER AS NEGATIVE 

LDAJAYLOO 

STAMULT_COUNT 

BUNMADAMADA 

SHLILI,STAM_FLAG_DOS// MARK NUMBER AS NEGATIVE 

LDAJAYLOO 

BSAABSOLUTE// GO AND GET ABSOLUTE VALUE OF DOS  

STAJAYLOO 

STAMULT_COUNT// NUMBER OF LOOP CYCLES FOR MULTIPICATION 

MADAMADA,LDATEMP4 

STAJAYZ 

BSACHCK_SIGN// CHECK IF DOS IS POSITIVE 

SNA 

BUNARRIVA // IF POSITIVE – START MULTIPLAYING 

STAM_FLAG_UNO// MARK NUMBER AS NEGATIVE 

LDAJAYZ 

BSAABSOLUTE// GO AND GET ABSOLUTE VALUE OF UNO 

STAJAYZ 

ARRIVA,LDAMULT_COUNT// MULTIPICATION SEQUENCE  

SZA 

BUNANDELLE 

FINITO,LDAM_FLAG_UNO// MULTIPICATION ENDING SEQUENCE  

STATEMP6 

LDAM_FLAG_DOS 

BSACHCK_SIGN// CHECK FINAL ANSWER SIGN 

SNA 

BUNPOS_ANS// IF FINAL ANSWER IS POSITIVE  

NEG_ANS,LDASUMMARY// IF FINAL ANSWER IS NEGATIVE 

CMA 

INC// TRANSFORM FINAL ANSWER TO NEGATIVE FORM 

GOBACK,BUNMULTIPLY_FUNC I//RETURN TO MAIN WITH NEGATIVE ANSWER 

POS_ANS,LDASUMMARY 

BUNGOBACK// RETURN TO MAIN WITH POSITIVE ANSWER 

ANDELLE,LDASUMMARY// ADDITION AS MULTIPICATION SEQUENCE 

ADDJAYZ 

STASUMMARY 

LDAMULT_COUNT// DECREASE COUNTER BY ONE 

ADDMINUS_ONE 

STAMULT_COUNT  

BUNARRIVA// RETURN AND CONTINUE MULTIPICATION PROCESS 

 

DIVIDE_FUNC,HEX0// DIVIDE FUNCTION INITIATED 

STA EMINEM 

SZA// CHECK IF REQUESTED TO DIVIDE BY ZERO 

BUNCHECK_NXT 

LDAERR_MSG_PTR// IF REQUESTED TO DIVIDE BY ZERO  

BSAPRINT_FUNC// PRINT ERROR 

BUNMAIN// GO TO MAIN AND START AGAIN 

CHECK_NXT,CLA 

STASUMMARY  

STAM_FLAG_UNO 

STAM_FLAG_DOS 

LDAEMINEM  

BSACHCK_SIGN// CHECK SIGN FOR DOS  

SNA 

BUNDALLE 

STAM_FLAG_DOS// IF THE SIGN IS NEGATIVE – RAISE FLAG 

BUNCHECK_NXTNXT// CHECK THE OTHER NUMBER 

DALLE,LDAEMINEM 

BSATRANS2NEG// TRANSFER TO NEGATIVE, IF POSITIVE 

STAEMINEM 

CHECK_NXTNXT,LDAUNO// LOAD UNO 

STA DRDRE 

BSACHCK_SIGN// CHECK SIGN FOR UNO 

SNA  

BUNTEILEN// IF UNO IS POSITIVE, CONTINUE TO DIVDIE SEQUENCE 

STAM_FLAG_UNO// IF THE SIGN IS NEGATIVE – RAISE FLAG 

LDADRDRE 

BSAABSOLUTE// RETURNS ABSOULTE VALUE 

STADRDRE 

TEILEN,LDADRDRE//START DIVIDING 

DIVARRIVA,SPA 

BUNDIVFINITO// IF NEGATIVE – REACHED MAX – GO TO FINISH 

ADDEMINEM 

SNA 

BUNWIEDER// CONTINUE DIVIDING 

BUNDIVFINITO// GO TO FINISH 

WIEDER,ISZ SUMMARY 

LDADRDRE 

ADDEMINEM 

STADRDRE 

BUNDIVARRIVA 

DIVFINITO,LDAM_FLAG_UNO 

STATEMP7 

LDAM_FLAG_DOS 

BSARSLT_SIGN// CHECK FINAL RESULT SIGN 

SNA 

BUNPOS_ANS2// IF FINAL RESULT IS POSITIVE  

NEG_ANS2,LDASUMMARY 

CMA// TRANSFER RESULT TO MINUS 

INC 

GOBACK2,BUNDIVIDE_FUNC I 

POS_ANS2,LDASUMMARY 

BUNGOBACK2 

 

 

 

///////////////////////////////////////////////////////OPERATORS DATA//////////////////////////////////////////////////////////////////////////// 

SHAKIRA,DEC0 

BEYONCE,DEC0 

JAYZ,DEC0 

JAYLOO,DEC0 

MINUS_ONE,DEC-1 

MULT_COUNT,DEC0 

SUMMARY,DEC0 

M_FLAG_UNO,DEC0 

M_FLAG_DOS,DEC0 

NEG_NUM,DEC-1 

POS_NUM,DEC0 

EMINEM,DEC0 

DRDRE,DEC0 

SNOOPDOGG,DEC0 

LLCOOLJ,DEC0 

RESULT,DEC0 

OUT_DIGIT,DEC0 

POS_MINUS,  HEX2D// "-" SIGN FOR PRINTING IN CASE NUMBER IS 

//NEGATIVE 

ASCII_VAL, HEX30 

ABSTRUCT,DEC0 

COUNT_MAX,DEC4 

COUNTER,DEC 0 

COUNTER2,DEC0  

 

DISMEMBER, HEX 450 

DISMM_PTR,HEX0 

 

 

 

 

ORG450 

DISMMBER_STR,  DEC-10000// DEAL WITH THE 10,000 

DEC-1000// DEAL WITH THE 1000 

DEC-100// DEAL WITH THE 100 

DEC-10// DEAL WITH THE 10 

 

 

 

CARRYOUT,HEX0// PRINT THE DISMEMBERD DIGIT 

OUT,SKO 

BUNOUT 

OUT 

BUN CARRYOUT I 

 

 

 

CHCK_SIGN,HEX0// CHECK SIGN IF VARIABLE ( + OR - ) 

SNA// IF ONLY ONE IS NEGATIVE 

BUN NOTNOT                                                              

LDANEG_NUM// RETURN NEGATIVE SIGN 

BUNCHCK_SIGN I 

NOTNOT,LDAPOS_NUM// IF NOT NEGATIVE, RETURN POSITIVE SIGN 

BUNCHCK_SIGN I 

 

 

 

 

 

ABSOLUTE,HEX0// INTERCEPT VALUE AND RETURNS THE ABSOLUTE VALUE 

SNA 

BUNJUST_RET// IF VALUE IS ALLREADY POSITIVE, RETURN ITSELF 

CMA 

INC 

JUST_RET,BUNABSOLUTE I 

 

 

 

 

TRANS2NEG,HEX0// TRANSFORM NUMBER INTO NEGATIVE FORM 

SPA 

BUNYALLA// IF NEGATIVE, RETURN AS IS 

CMA// IF POSITIVE, TRANSFER TO NEGATIVE 

INC 

YALLA,BUNTRANS2NEG I 

 

 

 

 

P_RMNDR,HEX 0 

LDARMNDR_PT_ST 

STARMNDR_PTR// RESTART PRINT POINTER TO START OF TEXT 

LDARMNDR_PTR I 

RMNDR_OP,SKO 

BUNRMNDR_OP 

OUT 

ISZ RMNDR_PTR// PROMOTE POINTER IN TEXT TO NEXT LETTER 

LDARMNDR_PTR I// LOAD NEXT LETTER 

ADDXXX// CHECK OF TERM OF TERMINATING PRINT 

SZA 

BUNADELLE// IF NOT FINISHED PRINTING, CONTINUE WITH NEXT 

//LETTER 

LDADRDRE// IF FINISHED PRINTING  

BSAPRNT_DIGITS// GO TO FUNCTION THAT PRINTS THE SOLUTION 

LDACR 

OUT 

BUNP_RMNDR I// RETURN TO MAIN 

ADELLE,LDARMNDR_PTR I 

BUNRMNDR_OP 

RSLT_SIGN,HEX0// CHECKS RESULT SIGN 

STASNOOPDOGG  

LDATEMP7 

STALLCOOLJ 

SNA 

BUNBLUSBLUS// IF FIRST NUMBER IS POSITIVE 

BUNMINSMINS// IF FIRST NUMBER IS NEGATIVE 

BLUSBLUS,LDASNOOPDOGG 

SNA 

BUNRET_PLUS// FIRST PLUS AND SECOND PLUS 

BUNRET_MINUS// FIRST PLUS AND SECOND MINUS 

MINSMINS,LDASNOOPDOGG 

SNA 

BUNRET_MINUS// FIRST MINUS SECOND PLUS 

BUNRET_PLUS// FIRST MINUS SECOND MINUS 

RET_MINUS,LDAMINUS_ONE 

FINITO2,BUNRSLT_SIGN I// RETURN TO DIVIDE FUNCTION 

RET_PLUS,CLA 

BUNFINITO2 

 

 

 

 

PRNT_DIGITS,HEX0// PRINTS DIGIT BY DIGIT 

STARESULT 

CLA// RESTART VARIABLS 

STAABSTRUCT 

STAOUT_DIGIT 

LDACOUNT_MAX 

STACOUNTER2 

LDADISMEMBER 

STADISMM_PTR// START DISMEMBER POINTER AT THE 10,000 DIGIT 

LDARESULT 

SNA 

BUNSTAYPOS// IF RESULT IS POSITIVE, SKIP TRANSFORMATION  

SWITCH2NEG, LDARESULT// IF RESULT IS NEGATIVE – TRASNFORM TO POSITIVE  

CMA   

INC 

STAABSTRUCT 

LDAPOS_MINUS// PRINT THE "-" SIGN  

BSACARRYOUT// GO AND PRINT THE DISMEMBERD DIGIT 

BUNHOLALOOP// GO TO OUT LOOP 

STAYPOS,LDARESULT   

STAABSTRUCT 

HOLALOOP,LDACOUNTER2// OUT LOOP INITATED  

SPA 

BUNENDLOOP 

CLA// WHILE COUNTER2 IS POSITIVE (NOT ZERO) CONTINUE  

STAOUT_DIGIT 

TULALOOP,LDADISMM_PTR  I// WHILE (Stripped - Power10Array[Ptr]  > 0) 

ADDABSTRUCT  

SNA 

BUN TULATULA// IF POSITIVE – STRIP DIGIT 

BUNENDTULA// IF NEGATIVE – FINISH DESMEMBERING - END  

//TULALOOP 

TULATULA,STAABSTRUCT  

ISZOUT_DIGIT 

BUNTULALOOP// IF NOT FINISHED – CONTINUE DISMEMBERING  

//NUMBER 

ENDTULA,LDAOUT_DIGIT// IF FINISHED – PRINT DIGIT 

ADDASCII_VAL// ADD ASCII VALUE TO VARIABLE TO RECEIVE DIGIT 

BSACARRYOUT// GO TO PRINTING FUNCTION TO PRINT DIGIT 

ISZDISMM_PTR  // PROMOTE THE POUNTER TO THE NEXT DIGIT 

LDACOUNTER2  

ADDMINUS_ONE 

STACOUNTER2// DEPROMOTE COUNTER  

BUNHOLALOOP// GO TO MAIN DISMEMBERING LOOP AND DO AGAIN 

ENDLOOP,LDAABSTRUCT// IF FINISHED DISMEMBERING THE NUMBER 

ADDASCII_VAL// ADD ASCII VALUE 

BSACARRYOUT// PRINT THE FINAL DIGIT OF THE NUMBER 

End,CLA 

BUNPRNT_DIGITS I 

 

 

 

 

 

 

 

PRNT_RESULT,HEX0// RESULT PRINTING FUNCTION 

STASOLUCION 

LDARSLT_P_STR 

STARSLT_P_PTR// RESTART PRINT POINTER TO START OF TEXT 

LDARSLT_P_PTR I 

RSLT_OP,SKO 

BUNRSLT_OP 

OUT 

ISZ RSLT_P_PTR// PROMOTE POINTER IN TEXT TO NEXT LETTER 

LDARSLT_P_PTR I// LOAD NEXT LETTER 

ADDXXX// CHECK OF TERM OF TERMINATING PRINT 

SZA 

BUNANDELE// IF NOT FINISHED PRINTING, CONTINUE WITH NEXT  

//LETTER 

LDASOLUCION// IF FINISHED PRINTING  

BSAPRNT_DIGITS// GO TO FUNCTION THAT PRINTS THE SOLUTION 

LDACR 

OUT 

CLA 

STASOLUCION// RESET SOLUTION  

BUNPRNT_RESULT I// RETURN TO MAIN 

ANDELE,LDARSLT_P_PTR I 

BUNRSLT_OP 

 

/////////////////////////////////////////////////////////////////RESULT PRINTING DATA//////////////////////////////////////////////////////////////////////// 

SOLUCION,DEC0 

CR,HEXD 

XXX,HEX-3B// STOP TERM IN RESULT TEXT PRINTING (:) 

RSLT_P_STR,HEX500 

RSLT_P_PTR,HEX0 

RMNDR_PT_ST,HEX 550 

RMNDR_PTR,HEX0 

 

 

 

 

 

ORG500 

RSLT_P,HEX0D// "The Result Is: " 

HEX54 

HEX68 

HEX65 

HEX20 

HEX52 

HEX65 

HEX73 

HEX75 

HEX6C 

HEX74 

HEX20 

HEX49 

HEX73 

HEX3A 

HEX 20 

HEX3B 

 

 

 

 

 

 

 

ORG 550 

RMNDR_P,HEX57// "With a reminder of: " 

HEX69 

HEX74 

HEX68 

HEX20 

HEX61 

HEX20 

HEX72 

HEX65 

HEX6D 

HEX69 

HEX6E 

HEX64 

HEX65 

HEX72 

HEX20 

HEX6F 

HEX66 

HEX3A 

HEX20 

HEX3B 

 

 

 

 

 

 

 

ORG 595 

INTRO,HEX0D// "Please Insert Operator (* , - , + , /) (Enter X To Terminate):" 

HEX50 

HEX6C 

HEX65 

HEX61 

HEX73 

HEX65 

HEX20 

HEX49 

HEX6E 

HEX73 

HEX65 

HEX72 

HEX74 

HEX20 

HEX4F 

HEX70 

HEX65 

HEX72 

HEX61 

HEX74 

HEX6F 

HEX72 

HEX20 

HEX28 

HEX2A 

HEX20 

HEX2C 

HEX20 

HEX2D 

HEX20 

HEX2C 

HEX20 

HEX2B 

HEX20 

HEX2C 

HEX2F 

HEX29 

HEX20 

HEX28 

HEX45 

HEX6E 

HEX74 

HEX65 

HEX72 

HEX20 

HEX58 

HEX20 

HEX54 

HEX6F 

HEX20 

HEX54 

HEX65 

HEX72 

HEX6D 

HEX69 

HEX6E 

HEX61 

HEX74 

HEX65 

HEX29 

HEX3A 

HEX3B 

 

 

 

ORG 695 

PRINT_NUMBS,HEX0D// "Please Enter Two Number (Enter For Insertion):" 

HEX50 

HEX6C 

HEX65 

HEX61 

HEX73 

HEX65 

HEX20 

HEX45 

HEX6E 

HEX74 

HEX65 

HEX72 

HEX20 

HEX54 

HEX77 

HEX6F 

HEX20 

HEX4E 

HEX75 

HEX6D 

HEX62 

HEX65 

HEX72 

HEX73 

HEX20 

HEX28 

HEX45 

HEX6E 

HEX74 

HEX65 

HEX72 

HEX20 

HEX46 

HEX6F 

HEX72 

HEX20 

HEX49 

HEX6E 

HEX73 

HEX65 

HEX72 

HEX74 

HEX69 

HEX6F 

HEX6E 

HEX29 

HEX3A 

HEX3B 

 

 

 

ORG 795 

ERR_MSG_P,HEX0D// "Input Error!" 

HEX49 

HEX6E 

HEX70 

HEX75 

HEX74 

HEX20 

HEX45 

HEX72 

HEX72 

HEX6F 

HEX72 

HEX21 

HEX3B 

 

 

ORG 900 

INP_DNIED_TXT,HEX0D// "Input Denied! Please Try Again" 

HEX49 

Hex6E 

HEX70 

HEX75 

HEX74 

HEX20 

HEX44 

HEX65 

HEX6E 

HEX69 

HEX65 

HEX64 

HEX21 

HEX20 

HEX50 

HEX6C 

HEX65 

HEX61 

HEX73 

HEX65 

HEX20 

HEX54 

HEX72 

HEX79 

HEX20 

HEX41 

HEX67 

HEX61 

HEX69 

HEX6E 

HEX3B 

 
